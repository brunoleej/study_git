# 알고리즘 복잡도 표현 방법
# 알고리즘 복잡도 계산이 필요한 이유 => 하나의 문제를 푸는데 알고리즘은 다양할 수 있음
# 1. 시간복잡도 : 알고리즘이 일정시간 내에 몇번을 돌았는지 계산
# 2. 공간복잡도 : 알고리즘이 사용하는 메모리 사이즈
# 알고리즘 시간 복잡도의 주요 요소 => 반복문이 지배합니다.

# 알고리즘 성능 표기법
# Big O Notation : O(N)
    # 알고리즘 최악의 실행시간을 표기
    # 가장 많이 / 일반적으로 사용함
    # 아무리 최악의 상황이더라도, 이정도의 성능은 보장한다는 의미임.

# Ω(오메가) Notation : Ω(N)
    # 오메가 표기법은 알고리즘 최상의 실행 시간을 표기

# Θ(세타) Notation : Θ(N)
    # 오메가 표기법은 알고리즘 최상의 실행 시간을 표기

# Big O Notation
# 빅 오 표기법, Big-O 표기법이라고도 부름
# O(입력)
    # 입력 n에 따라 결정되는 시간 복잡도 함수
    # O(1), O(log n), O(n), O(nlogn), O(n^2), O(n!)등으로 표기함
    # 입력 n의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음
        #  O(1) < O(log n) < O(n) < O(nlogn) < O(n^2) < O(n!)
# 단순하게 입력 n에 따라, 몇번 실행이 되는지를 계산하면 됩니다.


# 연습 1 : 1부터 n까지의 합을 구하는 알고리즘 직상
    # 힙을 기록할 변수를 만들고 0을 저장
    # n을 1부터 1씩 증가하면서 반복
    # 반복문 안에서 합을 기록할 변수에 1씩 증가된 값을 더함
    # 반복이 끝나면 합을 출력
def sum_all(n):
    total = 0
    for num in range(1, n + 1):
        total += num
    return total

print(sum_all(3))   # 6
print(sum_all(100)) # 5050